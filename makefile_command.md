## 显示命令

目的：有利于makefile调试。
方法：用“@”字符在命令行前，那么，这个命令将不被make显示出来。

```ruby
@echo 正在编译XXX模块......
```
会输出字符串，但不会输出命令执行的过程。

## 执行

make是顺序执行命令，但是当第二条命令依赖于第一条命令时，应该用分号分隔这两条命令，而不能写在两行。

```ruby
exec:
	cd /home/zhouyj
    pwd
```

输出  *makefile的当前路径*

```ruby
exec:
	cd /home/zhouyj；pwd
```

输出  */home/zhouyj*

## 忽略出错

每当命令运行完后，make会检测每个命令的返回码，如果命令返回成功，那么make会执行下一条命令，当规则中所有的命令成功返回后，这个规则就算是成功完成了。如果一个规则中的某个命令出错了（命令退出码非零），那么make就会终止执行当前规则，这将有可能终止所有规则的执行。

有些时候，命令的出错并不表示就是错误的。例如mkdir命令，我们一定需要建立一个目录，如果目录不存在，那么mkdir就成功执行，万事大吉，如果目录存在，那么就出错了。我们之所以使用mkdir的意思就是一定要有这样的一个目录，于是我们就不希望mkdir出错而终止规则的运行export variable = value
其等价于：

> * 命令行前加减号`-`，标记命令始终正确；
> * make -i ，忽略所有错误；
> * make -k ，终止出错命令的执行，执行其他命令。

## 嵌套执行make

形态：大型工程中，不同功能的源文件放在不同的目录中，在每个目录中写一个该目录的makefile。

目的：方便模块编译和分段编译，有利于维护整个工程。

例如:我们有一个子目录叫subdir，这个目录下有个Makefile文件，来指明了这个目录下文件的编译规则。那么我们总控的Makefile可以这样书写。

```ruby
subsystem:
        cd subdir && $(MAKE)
```

变量传递：传递变量到下级makefile，使用export

```ruby
export <variable ...>;
```
*如果你要传递所有的变量，那么，只要一个export就行了。后面什么也不用跟，表示传递所有的变量。*

## 命令包

如果Makefile中出现一些相同命令序列（可以看成函数），那么我们可以为这些相同的命令序列定义成一个变量。定义这种命令序列的语法以“define”开始，以“endef”结束。

例如：
```ruby
define run-yacc
yacc $(firstword $^)
mv y.tab.c $@
endef
```

```ruby
foo.c : foo.y
        $(run-yacc)
```
> * `run-yacc`是命令包的名字，不要和makefile中的变量重名。
> * `define`,`enddef`是命令序列。
> * 命令包的使用如同使用变量一样。






