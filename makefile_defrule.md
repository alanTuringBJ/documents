## 隐含规则

在Makefile中的“隐含的”，早先约定了的，不需要我们再写出来的规则。

> 把[.c]文件编译成[.o]文件这一规则，你根本就不用写出来，make会自动推导出这种规则，并生成我们需要的[.o]文件。

“隐含规则”会使用一些我们系统变量，我们可以改变这些系统变量的值来定制隐含规则的运行时的参数。

> 如系统变量“CFLAGS”可以控制编译时的编译器参数。

我们还可以通过“模式规则”的方式写下自己的隐含规则。

> 使用“模式规则”会更回得智能和清楚，但“后缀规则”可以用来保证我们Makefile的兼容性。

## 使用隐含规则

如果要使用隐含规则生成你需要的目标，你所需要做的就是不要写出这个目标的规则。那么，make会试图去自动推导产生这个目标的规则和命令，如果 make可以自动推导生成这个目标的规则和命令，那么这个行为就是隐含规则的自动推导。

```ruby
foo : foo.o bar.o
        cc –o foo foo.o bar.o $(CFLAGS) $(LDFLAGS)
```
这个Makefile中并没有写下如何生成foo.o和bar.o这两目标的规则和命令。因为make的“隐含规则”功能会自动为我们自动去推导这两个目标的依赖目标和生成命令。

当然，如果我们为[.o]文件书写了自己的规则，那么make就不会自动推导并调用隐含规则，它会按照我们写好的规则忠实地执行。

## 自动化变量

自动化变量，就是这种变量会把模式中所定义的一系列的文件自动地挨个取出，直至所有的符合模式的文件都取完了。这种自动化变量只应出现在规则的命令中。

自动化变量表

自动化变量名|说明
:---:|:---
$@|规则中的目标文件集
$%|仅当目标是函数库文件中，表示规则中的目标成员名
$<|依赖目标中的第一个目标名字，如果依赖目标是模式定义，则表示符合模式的一系列文件
$?|所有比目标新的依赖目标的集合，以空格分隔
$^|所有依赖目标的集合，如果集合中出现重复，则删除重复的依赖，保留一份
$+|所有依赖目标的集合，允许重复
$*|避免使用







